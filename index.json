[{"categories":["effective-java"],"content":"Effective Java: Consider a builder when faced with many constructor parameters.","date":"2018-11-08","objectID":"/consider-a-builder-when-faced-with-many-constructor-parameters/","tags":null,"title":"Consider a builder when faced with many constructor parameters","uri":"/consider-a-builder-when-faced-with-many-constructor-parameters/"},{"categories":["effective-java"],"content":"Item 2: Consider a builder when faced with many constructor parameters. In the previous item, we discussed how static factory methods should be a preferred choice over constructors. While the above method works in most cases, in cases where there are a bunch of optional parameters it does not scale well. The book consist of an example of a class that represents a Nutrition Facts label. This class would have a bunch of fields. Many of them would be required, and many would be optional. To create an instance of such a class, you have a few options. Use the telescoping constructor pattern. This pattern would have a constructor with all the required parameters. Adding to that, it would have constructors with the required parameters with one optional parameter, 2 optional parameters, 3 optional parameters and so on. Here is an example given in the book. public class NutritionFacts { private final int servingSize; //required private final int servings; //required private final int calories; //optional private final int fat; //optional private final int carbohydrates; //optional public NutritionFacts(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public NutritionFacts(int servingSize, int servings, int calories) { this.servingSize = servingSize; this.servings = servings; this.calories = calories; } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; } public NutritionFacts(int servingSize, int servings, int calories, int fat, int carbohydrates) { this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.carbohydrates = carbohydrates; } } With the above pattern, often you still need to pass in null/zero values for parameters that you are not interested in. The other problem with the above method is that it is not readable. The client of the above class would need to know exactly the order of the parameters in the constructor and hence prone to runtime errors. Use the java beans pattern. IUn this pattern, you create an instance using a non-parameterized constructor and then use setter methods to set values for fields you are interested in. Here is an example: public class NutritionFacts { private final int servingSize = -1; //required private final int servings = -1; //required private final int calories = 0; //optional private final int fat = 0; //optional private final int carbohydrates = 0; //optional public NutritionFacts() { } // setter methods for the above fields. } // Client use NutritionFacts facts = new NutritonFacts(); facts.setServingSize(10); facts.setServings(1); facts.setFat(10); The above pattern has flaws. As the object is created by invoking the constructor and then the fields are set subsequently across multiple statements, the object may be in an inconsistent state during its construction. In usual cases, the constructor would be responsible for checking the validity of all parameters and create an instance only if the parameters are valid unlike above. We also cannot use the above pattern in cases of immutable classes. As the construction of the object spans across multiple statements, thread safety is a concern in multi-threaded environments. Use the builder pattern. This is considered as a best way to create objects which has a lot of optional parameters. Here we introduce a builder class as a static nested class in the main class(candidate class). This builder class exposes the same setter methods for the fields that are optional in the parent class along with a constructor with the required parameters. The client can create an instance of the builder class and then call the build method on the builder object to create an instance of the parent(main) class. Here is an example: public class NutritionFacts { private final int servingSize; //required private final int servings; //required private fin","date":"2018-11-08","objectID":"/consider-a-builder-when-faced-with-many-constructor-parameters/:0:0","tags":null,"title":"Consider a builder when faced with many constructor parameters","uri":"/consider-a-builder-when-faced-with-many-constructor-parameters/"},{"categories":["effective-java"],"content":"Effective Java: Consider factory methods instead of constructors.","date":"2018-10-22","objectID":"/static-factory-methods-instead-of-constructors/","tags":null,"title":"Static factory methods instead of constructors","uri":"/static-factory-methods-instead-of-constructors/"},{"categories":["effective-java"],"content":"A while ago I started reading a highly recommended book for Java developers - Effective Java(2nd edition) by Joshua Bloch. This book has a wealth of knowledge about how to write effective java code and not make common mistakes that affect the performance and in some cases, correctness of your code. Over the course of next few months, I intend to write more of my learnings and summarize the items from the book. Item 1: Consider static factory methods instead of constructors. Here the author discusses one of the ways one can allow clients of a particular class to create instances without using a constructor, the static factory method. Static factory method : A simple static method that returns an instance of the class. Example: public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Boolean.FALSE; } Advantages Unlike constructors, factory methods have names. This has many advantages. A well chosen name is easier to use and the client code easier to read. A class can have only a single constructor with a given signature. Often developers will change the order of the parameters and create new constructors. This would result in the client to remember the order of the arguments to pass to the constructor. This is really bad design. Using factory methods, the developer can give a logical name to different methods resulting in better code readability. Unlike constructors, they are not required to create a new object every time it is invoked. With static factory methods, you as a developer of the class has an option to limit the number of instances of the class. These classes are called instance-controlled classes. This is very useful when the creating a new object of the class is an expensive operation. An example given in the book is about the valueOf method in the Boolean class(example above). Here each time the method is invoked, one of the 2 values are returned. This way of creating and caching objects is also used in extensively in the lazy initialization of singleton objects. One added benefit of this is, you can check for objects being equal by using the == operator rather than the equals method. Unlike constructors, they can return an object of any subtype of their return type. This gives you the flexibility in choosing the class of the returned object. This also gives you the flexibility of making your API very thin by not making the implementation classes public. Consider the List interface in Java. For one to define a static factory method is not an option as interfaces cannot have static methods. Hence we have a non-instantiable class Collections which has a bunch of static factory methods that return implementations of various collection interfaces. Many of these implementations are not made public. Hence with future versions of the release of Java, the authors can choose to add/change/replace these implementations without affecting the client code. One example of adding new implementation is the Service provider framework. Example: JDBC. In the service provider framework, there are 3 main interfaces: The service interface which providers implement. The provider registration API which the system uses to register the provider implementations. The service access API which the clients use to obtain an instance of the service. The service provider interface which providers implement to create instances of their service implementation. With reference to JDBC: Connection = service interface. DriverManager.registerDriver = provider registration API. DriverManager.getConnection = service access API. Driver = service provider interface. Disadvantages Providing only static factory methods is that class without public or protected constructors cannot be subclassed. Static factory methods are not easily distinguished from other static methods. This is mainly the result of the current javadoc tool as it does not have a separate section like constructors. To avoid this, naming static factory methods in a consistent way wou","date":"2018-10-22","objectID":"/static-factory-methods-instead-of-constructors/:0:0","tags":null,"title":"Static factory methods instead of constructors","uri":"/static-factory-methods-instead-of-constructors/"},{"categories":["algorithms"],"content":"Solving Unique Substrings in Wraparound String on Leetcode.","date":"2018-09-09","objectID":"/unique-substrings-in-wraparound-string/","tags":null,"title":"Unique Substrings in Wraparound String","uri":"/unique-substrings-in-wraparound-string/"},{"categories":["algorithms"],"content":"Solving Unqiue Substrings in Wraparound String problem on Leetcode. The overall gist of the problem is as follows: Given a string p, you need to find the total count of all the non-empty unique substrings of p, present in a infinite wraparound string of abcdefghijklmnopqrstuvwxyz, where length of p could be over 10000 characters. The brute force solution to this problem would be to go over all the substrings of p and check if they are present in the above wraparound string. The time complexity of this solution would be of the order of O(n3). We can do better with dynamic programming. To avoid duplicates in our final count, we would need to somehow keep track of all the substrings we have already added to our count. Doing this would require a lot of memory. Instead, what if we kept track of the length of the maximum substring ending in a particular character and update it as and when we find a new substring ending in the same character. While doing so, we also substract the previous maximum from the total and add the new maximum to the total to avoid the duplicate count. public int findSubstringInWraproundString(String p) { if (p.length() \u003c 1) { return p.length(); } Map\u003cCharacter, Integer\u003e charToSubstringCount = new HashMap\u003c\u003e(); int prevCount = 1; int total = 1; charToSubstringCount.put(p.charAt(0), 1); for (int i = 1; i\u003cp.length(); ++i) { char currentChar = p.charAt(i); char prevChar = p.charAt(i-1); int currentCount = 1; if (currentChar == 'a') { if (prevChar == 'z') { currentCount = prevCount + 1; } } else if (prevChar + 1 == currentChar) { currentCount = prevCount + 1; } if (!charToSubstringCount.containsKey(currentChar)) { charToSubstringCount.put(currentChar, currentCount); total += currentCount; } else { if (currentCount \u003e charToSubstringCount.get(currentChar)) { total = total - charToSubstringCount.get(currentChar) + currentCount; charToSubstringCount.put(currentChar, currentCount); } } prevCount = currentCount; } return total; } For example Consider p to be abzabc. a in itself is a valid substring so we start with the total count to be 1 and we use the prevCount to count the length of the substring which is valid, in this case, the consecutive elements are part of the above wraparound string, till the previous character. Starting at index 1, we check if the previous character and current character form a valid substring. If they do, we increase the length of the valid substring to include the current character. Once we have the length of the substring ending at the current character, we check if we already have seen a substring ending in the current character previously. If we do, and its length was smaller than the current substring length, we substract the previous length and add the new length. Index. Maximum Length ending in character. Total 0 a-\u003e1 1 1 a-\u003e1, b-\u003e2 3 2 a-\u003e1, b-\u003e2, z-\u003e1 4 3 b-\u003e2, z-\u003e1, a-\u003e2 5 4 z-\u003e1, a-\u003e2, b-\u003e3 6 5 z-\u003e1, a-\u003e2, b-\u003e3, c-\u003e4 10 The above solution has O(n) time complexity and O(1) space complexity. ","date":"2018-09-09","objectID":"/unique-substrings-in-wraparound-string/:0:0","tags":null,"title":"Unique Substrings in Wraparound String","uri":"/unique-substrings-in-wraparound-string/"},{"categories":["algorithms"],"content":"I was solving the problem Largest Divisible Subset on Leetcode a while back. The problem is as follows: Given a set of distinct positive integers, we need to find the largest subset of this set such that every pair(E1, E2) of elements in that set satisfy one of the following conditions: E1 % E2 == 0 E2 % E1 == 0 If there are multiple such subsets, we can return any one of them. The brute force solution to this problem would be to generate all subsets of a given input set and then return a largest set that satisfies the above criteria. The time complexity would be O(2n) + the time taken to check if the required criteria is satisfied. We can do better with dynamic programming. The crux of the problem is noticing the following transitive property emitted by numbers that are divisible. If A % B == 0 \u0026\u0026 B % C == 0 then A % C == 0 for any A\u003cB\u003cC. For us to work with the above property, we need to first sort the input array. The recursive formula then would be: Dpi = Max of 1 + Dpj over all j in the range (0…i-1) which satisfy numsi % numsj == 0. We can solve this in the bottom-up fashion while keeping track of the largest and parent values for each index. The parent value array would help us recreate the largest set. public List\u003cInteger\u003e largestDivisibleSubset(int[] nums) { int len = nums.length; List\u003cInteger\u003e ans = new ArrayList\u003c\u003e(); if (len == 0) { return ans; } Arrays.sort(nums); // This array holds the index of previous member of the largest set ending at i. int[] parent = new int[len]; // This array holds the size of largest divisible set ending at index i including i. int[] largest = new int[len]; int maxSubset = 1; int maxSubsetIndex = 0; for (int i = 0; i\u003clen; ++i) { largest[i] = 1; parent[i] = -1; for (int j = 0; j \u003c i; ++j) { if (nums[i] % nums[j] == 0 || nums[j] % nums[i] == 0) { if (largest[j] + 1 \u003e largest[i]) { largest[i] = largest[j] + 1; parent[i] = j; } } if (largest[i] \u003e= maxSubset) { maxSubset = largest[i]; maxSubsetIndex = i; } } } // Create the answer subset. int index = maxSubsetIndex; while (index != -1) { ans.add(0, nums[index]); index = parent[index]; } return ans; } The above solution has O(n2) time complexity and O(n) space complexity. ","date":"2018-06-16","objectID":"/largest-divisible-subset/:0:0","tags":null,"title":"Largest Divisible Subset","uri":"/largest-divisible-subset/"},{"categories":["os"],"content":"Understanding the difference between user-level threads and kernel-level threads.","date":"2017-10-26","objectID":"/user-kernel-level-threads/","tags":null,"title":"User and Kernel Level Threads","uri":"/user-kernel-level-threads/"},{"categories":["os"],"content":"Kernel-Level Theads These threads are also known as “OS-level threads” or “native threads”. Kernel-level threads are managed by the OS. This means all thread scheduling happens in the kernel. For that to happen, the kernel maintains a thread table that keeps track of all threads in the system. These threads are created by making a system call into the OS. Advantages: The scheduler can give more time to a process having a large number of threads rather than to a process having a smaller number of threads. This is possible as it keeps track of all threads in the system. Disadvantages: These threads are slow because they need to switch into the kernel mode for scheduling purposes. As the kernel is not only responsible for scheduling at the process level but also at the thread level, it increases the kernel complexity. ","date":"2017-10-26","objectID":"/user-kernel-level-threads/:0:1","tags":null,"title":"User and Kernel Level Threads","uri":"/user-kernel-level-threads/"},{"categories":["os"],"content":"User-Level Threads These threads are also known as “green threads”. These threads are managed by the user-level runtime library and not the OS. The kernel knows nothing about the user-level threads and as far it is concerned, it is only managing a single-threaded process. Most of the thread level activities like creating new threads, switching between threads, syncronization, all happen without kernel involvement. One other thing to keep in mind is that some blocking calls like reading a file (data = file.read()) are converted to asynchronous calls by the user-level library so other user level threads are not blocked. Advantages: Much faster than kernel-level threads as switching of modes betwen user mode to kernel mode is not required for most thread level activities. Disadvanges: As the kernel has no information regarding user-level threads, it does not have a process level thread count. Hence process scheduling decisions are not made keeping the thread count. A single blocking call by a user-level thread can block the entire process. To overcome this, most OS kernels have a scheduler activations mechanism. Read more about it here. More References: TutorialsPoint Oracle Illinois Institute of Technology Stack Overflow ","date":"2017-10-26","objectID":"/user-kernel-level-threads/:0:2","tags":null,"title":"User and Kernel Level Threads","uri":"/user-kernel-level-threads/"},{"categories":["algorithms"],"content":"Solving Wiggle Subsequence on Leetcode.","date":"2017-10-24","objectID":"/wiggle-subsequence/","tags":null,"title":"Wiggle Subsequence","uri":"/wiggle-subsequence/"},{"categories":["algorithms"],"content":"I was solving a problem called Wiggle Subsequence on leetcode today. I spent sometime thinking of the solution to the problem before I realized that there was a similar named problem I had solved recently. Longest Increasing Subsequence. One of the solutions to the problem runs in O(n2) time. That solution calculates the longest increasing subsequence of a given index i by checking the longest increasing subsequence for all indices j \u003c i for which nums[i] \u003e nums[j]. Check here. Based on that, I devised a similar solution that ran in O(n2) time using O(2n) space. public int wiggleMaxLength(int[] nums) { int len = nums.length; if (len \u003c 2) { return len; } int[] parent = new int[len]; int[] count = new int[len]; parent[0] = -1; count[0] = 1; for (int i = 1; i \u003c len; ++i) { for(int j = 0; j\u003ci; ++j) { int currentDiff = nums[i] - nums[j]; // If currentDiff is zero, it means that you can either // include i or j but not both. if (currentDiff == 0) { if (count[j] \u003e count[i]) { parent[i] = parent[j]; count[i] = count[j]; } continue; } // If there is no previous number to j then assume // this is the first pair in the wiggle subsequenence. if (parent[j] == -1) { parent[i] = j; count[i] = count[j] + 1; continue; } int parentDiff = nums[j] - nums[parent[j]]; if (((currentDiff \u003e 0) \u0026\u0026 (parentDiff \u003c 0)) || ((currentDiff \u003c 0) \u0026\u0026 (parentDiff \u003e 0))) { if (count[j] + 1 \u003e count[i]) { parent[i] = j; count[i] = count[j] + 1; } } } } int ans = count[0]; for (int i = 1; i \u003c len; ++i) { ans = Math.max(ans, count[i]); } return ans; } On optimizing the above solution, one could argue that instead of looking at all the j elements before i, we could just look at the value of i-1. This is how that would work: public int wiggleMaxLength(int[] nums) { int len = nums.length; if (len \u003c 2) { return len; } int parent = -1; int count = 1; for (int i = 1; i \u003c len; ++i) { int currentDiff = nums[i] - nums[i-1]; // If currentDiff is zero, it means that you can either // include i or i-1 but not both. if (currentDiff == 0) { continue; } // If there is no previous number to i-1 then assume // this is the first pair in the wiggle subsequenence. if (parent == -1) { parent = i-1; count = count + 1; continue; } int parentDiff = nums[i-1] - nums[parent]; if (((currentDiff \u003e 0) \u0026\u0026 (parentDiff \u003c 0)) || ((currentDiff \u003c 0) \u0026\u0026 (parentDiff \u003e 0))) { parent = i - 1; count = count + 1; } } return count; } If you notice the above solution, you can see that there are 3 states that the currentDiff can be in: nums[i] \u003e nums[i-1] nums[i] \u003c nums[i-1] nums[i] = nums[i-1] In state 3, we do nothing as the difference is neither positive nor negative and hence both i and i-1 could not be counted towards the final count. In state 1, if parentDiff, which is nothing but nums[i-1] - nums[parent], is negative, it means that element i adheres to the requirements and hence we increase the count. If parentDiff is positive, it means that you can either have i-1 or i as part of the final count, but not both. This would mean that the parent of i would be the same as parent of i-1. In state 2, we follow the similar logic as in state 1 mentioned above. The above solution has O(n) time complexity and O(1) space complexity. ","date":"2017-10-24","objectID":"/wiggle-subsequence/:0:0","tags":null,"title":"Wiggle Subsequence","uri":"/wiggle-subsequence/"},{"categories":null,"content":"First blog post.","date":"2017-10-23","objectID":"/first-blog/","tags":null,"title":"First Blog","uri":"/first-blog/"},{"categories":null,"content":"Hello all! This is my first blog. Excitied to get this ball rolling. ","date":"2017-10-23","objectID":"/first-blog/:0:0","tags":null,"title":"First Blog","uri":"/first-blog/"},{"categories":null,"content":"I am currently a Software Engineer at WePay working in the Risk Infrastructure team. This team is mainly responsible for developing services that help us detect fraud by reviewing payments and help decrease fraud losses for the company. Before joining WePay, I was part of the Internal Systems Engineering team. Specifically, I am in the Tools sub-team, where I worked on developing and maintaining tools for the internal support organization. Before joining Cloudera, I worked at BlackRock briefly as a Software Engineer. There, I worked as part of the Portfolio Management team as well as Securities Lending team. Prior to joining BlackRock, I was a graduate student pursuing Masters in Computer Science at New York University. ","date":"2017-10-22","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]